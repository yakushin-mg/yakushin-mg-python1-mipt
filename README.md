# yakushin-mg-python1-mipt

Версия Python3 3.11.1 и выше

Шифрование

Описание:
Этот проект реализует простое консольное приложение на Python для шифрования и дешифрования текстовых файлов с помощью:
1) шифра Цезаря
2) шифра Виженера
3) шифра Вернама
Также есть функция автоматический взлома шифра Цезаря методами частотного анализа.
(Если хватит времени, хотелось бы реализовать другие варианты шифрования файлов, например, матричный)


Архитектура:
На вход подаются аргументы командной строки:
1) режим (дешифрование или шифрование файла определенным способом)
2) <input.txt> (файл, откуда брать исходный текст)
3) <output.txt> (файл, куда записывать результат)
   python3 encryption.py <input.txt> <output.txt> <mode> [parameter]
Программа считывает построчно текст из <input.txt>. В зависимости от режима вызывается определенная функция: шифрование, дешифрование или взлом. При шифровании или дешифровании также в командной строке указывается тип и параметр (у Цезаря - сдвиг, у Виженера и Вернама - ключ). Затем результат записывается в <output.txt>.


Функции:

1) Шифр Цезаря - сдвигает буквы на указанное количество позиций, поэтому в параметрах функции будет исходный текст и параметр сдвига (число):
   У каждого элемента узнаем его код в Unicode формате с помощью ord(), затем к нему прибавляем параметр сдвига, и с помощью char() получаем новый символ. При дешифровании отнимаем параметр сдвига.

2) Шифр Виженера - использует ключевое слово для повторения ключа и шифрует текст по ключу, поэтому в параметрах функции будет исходный текст и ключ:
   У каждого элемента ключа узнаем его код в Unicode формате с помощью ord(), сохраняя это в массиве unicode_key. Затем циклом проходимся по каждому элементу изначальной строки и прибавляем к коду символа unicode_key[i % len(unicode_key)] (это почти шифр Цезаря, только несколько параметров). При дешифровании проводим обратные операции.

3) Шифр Вернама - одноразовый блокнот, где каждая буква текста XOR'ится с соответствующей буквой ключа, поэтому в параметрах функции будет исходный текст и ключ:

   Ключ должен быть не меньше, чем длина самого сообщения. Каждый элемент сообщения и ключа переводим в Unicode-формат, а затем переводим полученные числа в двоичную записи с помощью bin(). Проводим XOR этих двух чисел, затем переводим число в десятичную запись с помощью int("...", 2), после этого получаем новый элемент с помощью char(). При дешифровании проводим обратные операции. Единственное, что будет изменено - не будет проводиться XOR элементов. Таблица XOR:
   0 + 0 = 0
   0 + 1 = 1
   1 + 0 = 1
   1 + 1 = 0
То есть, зная полученный результат и значение элемента ключа в двоичной записи, можно однозначно восстановить значение элемента в сообщении.

5) Автоматический взлома шифра Цезаря методами частотного анализа - на вход подается только исходный текст:
   Добавляем таблицу частот появления символа алфавита в тексте. Считаем частоту появления каждого символа в зашифрованном тексте. Затем сравниваем значения и сопоставляем элементы в зашифрованном тексте и в таблице, тем самым определяя чему равен каждый символ.
