# yakushin-mg-python1-mipt

Версия Python3 3.11.1 и выше

Шифрование

Описание:
Этот проект реализует простое консольное приложение на Python для шифрования и дешифрования текстовых файлов с помощью:
1) шифра Цезаря
2) шифра Виженера
3) шифра Вернама
Также есть функция автоматический взлома шифра Цезаря методами частотного анализа.
(Если хватит времени, хотелось бы реализовать другие варианты шифрования файлов, например, матричный)

Описание работы приложения
Запуск происходит с помощью командной строки
   python3 encryption.py <input.txt> <output.txt> <mode> [parameter]

На вход подаются аргументы командной строки:
   1) <input.txt> (файл, откуда брать исходный текст)
   2) <output.txt> (файл, куда записывать результат)
   3) режим (дешифрование или шифрование файла определенным способом)
   4) параметр (при шифровании или дешифровании)
Программа считывает построчно текст из <input.txt>. В зависимости от выбранного режима выбирается класс и вызывается определенный метод : шифрование, дешифрование или взлом (только у шифра Цезаря). Описание работы методов написано ниже. Затем результат записывается в <output.txt>.

Архитектура
Cделаем три класса по типу шифрования:
1) Caesar's_cipher
   В нем будет три статических метода: шифрование, дешифрование и автоматический взлом
   1. Шифрование (исходный текст, параметр сдвига)
      Шифр Цезаря сдвигает буквы на указанное количество позиций, поэтому в параметрах функции будет исходный текст и параметр сдвига (число):
      У каждого элемента узнаем его код в Unicode формате с помощью ord(), затем к нему прибавляем параметр сдвига, и с помощью char() получаем          новый символ.
   2. Дешифрование (зашифрованный текст, параметр сдвига)
      При дешифровании выполняется точно такой же алгоритм, что и при шифровании, но параметр сдвига умножается на -1.
   3. Автоматический взлома шифра Цезаря методами частотного анализа (зашифрованный текст)
      Добавляем таблицу частот появления символа алфавита в тексте. Считаем частоту появления каждого символа в зашифрованном тексте. Затем           сравниваем значения и сопоставляем элементы в зашифрованном тексте и в таблице, тем самым определяя чему равен каждый символ.

2) Vigenеre_cipher
   В нем будет два статических метода: шифрование и дешифрование
   1. Шифрование (исходный текст, ключ-слово)
      Шифр Виженера - использует ключевое слово для повторения ключа и шифрует текст по ключу, поэтому в параметрах функции будет исходный текст и       ключ. У каждого элемента ключа узнаем его код в Unicode формате с помощью ord(), сохраняя это в массиве unicode_key. Затем циклом проходимся       по каждому элементу изначальной строки и прибавляем к коду символа unicode_key[i % len(unicode_key)] (это почти шифр Цезаря, только                несколько параметров).
   2. Дешифрование (зашифрованнай текст, ключ-слово)
      При дешифровании проводим обратные операции.

3) Vernam_cipher
   В нем будет два статических метода: шифрование и дешифрование
   1. Шифрование (исходный текст, ключ)
      Шифр Вернама - одноразовый блокнот, где каждая буква текста XOR'ится с соответствующей буквой ключа, поэтому в параметрах функции будет            исходный текст и ключ. Ключ должен быть не меньше, чем длина самого сообщения. Каждый элемент сообщения и ключа переводим в Unicode-формат,        а затем переводим полученные числа в двоичную записи с помощью bin(). Проводим XOR этих двух чисел, затем переводим число в десятичную             запись с помощью int("...", 2), после этого получаем новый элемент с помощью char().
   2. Дешифрование (зашифрованный текст, ключ)
      При дешифровании проводим обратные операции. Единственное, что будет изменено - не будет проводиться XOR элементов. Таблица XOR:
      0 + 0 = 0
      0 + 1 = 1
      1 + 0 = 1
      1 + 1 = 0
      То есть, зная полученный результат и значение элемента ключа в двоичной записи, можно однозначно восстановить значение элемента в сообщении.
